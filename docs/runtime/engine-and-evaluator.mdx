# Engine & Evaluator

## `Engine`

`Engine` is a minimal evaluator for direct expression-node evaluation:

```python
from laakhay.ta.expr.runtime import Engine

engine = Engine()
out = engine.evaluate(expression_node, dataset_map)
```

Useful for simple internal use, but most applications should use expression `.run(...)` with planner/evaluator.

## Planner-Evaluator Path

`Expression.run(dataset)` uses planned graph evaluation:

- build canonical graph
- compute node order
- evaluate dependencies first
- cache node outputs keyed by graph hash/alignment/symbol/timeframe

This is the default robust path for strategy execution.

## RuntimeEvaluator

`RuntimeEvaluator` is dataset-aware and resolves multi-source contexts with source expression support.

It is suitable for service-layer execution where dataset composition and source resolution are explicit concerns.

## Incremental Backend

Incremental execution now runs through the Rust backend lifecycle:

1. `initialize(plan, history)`
2. `step(plan, tick)` following `(state, update) -> (new_state, output)`
3. `snapshot(plan)`
4. `replay(plan, snapshot, events)`

Python no longer owns incremental node-step adapter logic.

## Alignment Behavior

For binary numeric/comparison operations:

- non-scalar series are aligned according to active alignment policy,
- scalar-literal series use scalar broadcasting semantics.

Control alignment via planner alignment context.
